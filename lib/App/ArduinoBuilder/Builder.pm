package App::ArduinoBuilder::Builder;

use strict;
use warnings;
use utf8;

use App::ArduinoBuilder::Config 'get_os_name';
use App::ArduinoBuilder::FilePath 'find_all_files_with_extensions';
use Exporter 'import';
use File::Basename 'basename';
use File::Path 'make_path';
use File::Spec::Functions 'catfile';

our @EXPORT_OK = qw(build_file build_archive build_object_files link_executable run_hook);

my @supported_source_extensions = qw(c cpp S ino);

sub _execute {
  my ($cmd) = @_;
  print "${cmd}\n";
  system($cmd) and die "Can’t execute the following command: $!\n\t${cmd}\n";
  return 1;
}

sub _run_recipe_pattern {
  # It’s undocumented but any recipe can have several patterns (and this is used
  # by several cores).
  my ($recipe_name, $config, %options) = @_;
  my $recipes = $config->filter("recipe.${recipe_name}");
  for my $k (sort $recipes->keys()) {
    die "Invalid recipe name: recipe.${recipe_name}.${k}\n" unless $k =~ m/^(?:\d+\.)?pattern$/;
    _execute($recipes->get($k, base => $config, %options));
  }
  return;
}

# This method is a very partial implementation of:
# https://arduino.github.io/arduino-cli/0.32/sketch-build-process/#pre-processing
# TODO: theoritically all .ino and .pde (?) files should be concatenated together
# rather than processed separately.
# TODO: we need to generate prototypes for the methods, using ctags.
sub _ino_to_cpp {
  my ($source, $target, $config) = @_;
  my $recipe;
  # This is ugly but we can’t easily do this elsewhere because we need the recipe command to be
  # resolved to be able to find the MMD flag, but we can’t resolve it too early because some
  # parameters will vary with each call.
  if (!$config->exists('recipe.preproc.macros')) {
    # We assume that this recipe exists (and that it’s not a multi-pattern recipe).
    $recipe = $config->get('recipe.cpp.o.pattern', allow_partial => 1, with => {source_file => $source, object_file => "${target}.cpp-pre"});
    # This is a heuristic because the '-x c++' must appear before the source file, so we can’t put
    # it at the end. It’s unclear how this command is actually generated by the Arduino GUI.
    $recipe =~ s/(?<=\s)-MMD\b/-w -x c++ -E -CC/ or die "Can’t modify the recipe.cpp.o.pattern command: ${recipe}.\n";
  } else {
    # It’s weird but this is not a "pattern" recipe. Why?
    $recipe = $config->get('recipe.preproc.macros', with => {source_file => $source, preprocessed_file_path => "${target}.cpp-pre"});
  }
  _execute($recipe);

  # TODO: there is a step in the real Arduino tool that is badly documented but which uses ctags to extract the
  # prototype of the functions in the .ino files (and adds them at the beginning of the C++ file), so that the
  # functions can be called before they are declared.
  # my $null = get_os_name() eq 'windows' ? 'nul' : '/dev/null';
  open my $fi, '<', "${target}.cpp-pre" or die "Can’t open intermediate file '${target}.cpp-pre' for reading: $!\n";
  open my $fo, '>', "${target}.cpp" or die "Can’t open intermediate file '${target}.cpp' for writing: $!\n";
  print $fo "#include \"Arduino.h\"\n";
  while (my $l = <$fi>) {
    print $fo $l;
  }
  close $fi;
  close $fo;
  return;
}

# dirname($target) must already exist.
sub build_file {
  my ($source, $target, $config) = @_;
  my @ext = $source =~ m/\.([^.]+)$/;
  die "File '$source' has no recognizable extension.\n" unless @ext;
  my $ext = $ext[0];
  if ($ext eq 'ino') {
    _ino_to_cpp($source, $target, $config);
    $source = $target.'.cpp';
    $ext = 'cpp';
  }
  _run_recipe_pattern("${ext}.o", $config, with => {source_file => $source, object_file => $target});
  return;
}

sub _add_to_archive {
  my ($object_file, $archive, $config) = @_;
  _run_recipe_pattern('ar', $config, with => {object_file => $object_file, archive_file => $archive, archive_file_path => catfile($config->get('build.path'), $archive)});
  return;
}

# target_dir has all the intermediate file, $archive is a file name that goes in build.path.
sub build_archive {
  my ($source_dirs, $target_dir, $archive, $config) = @_;
  make_path($target_dir);
  for my $d (@{$source_dirs}) {
    my @sources = find_all_files_with_extensions($d, [@supported_source_extensions]);
    for my $s (@sources) {
      # BUG: There is a bug if several files have the same name in the core, but this is improbable...
      my $object_file = catfile($target_dir, basename($s).'.o');
      build_file($s, $object_file, $config);
      _add_to_archive($object_file, $archive, $config);
    }
  }
}

sub build_object_files {
  my ($source_dir, $target_dir, $excluded_dirs, $config) = @_;
  make_path($target_dir);
  my @sources = find_all_files_with_extensions($source_dir, [@supported_source_extensions], $excluded_dirs);
  my @all_objects;
  for my $s (@sources) {
      # Same BUG here as in build_archive
      my $object_file = catfile($target_dir, basename($s).'.o');
      build_file($s, $object_file, $config);
      push @all_objects, $object_file;
  }
  return @all_objects;
}

sub link_executable {
  my ($object_files, $archive, $config) = @_;
  _run_recipe_pattern('c.combine', $config, with => {object_files => join(' ', @{$object_files}), archive_file => $archive, archive_file_path => catfile($config->get('build.path'), $archive)});
  return;
}

sub run_hook {
  my ($hook_name, $config) = @_;
  _run_recipe_pattern("hooks.${hook_name}", $config);
  return;
}
